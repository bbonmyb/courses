# "Поколение Python": курс для продвинутых

# конспект конспект конспект конспект конспект конспект конспект конспект конспект конспект конспект конспект конспект конспект конспект конспект

#логический тип данных bool
'''
# Логический тип bool в Python — принимает два значения: True (истина) и False (ложь).

# bool — подкласс int:
print(type(True))          # <class 'bool'>
print(isinstance(True, int))  # True
print(True == 1)           # True
print(False == 0)          # True

# Логические значения участвуют в арифметике:
print(True + 4)            # 5
print(5 * False)           # 0

# Логические операторы:
print(True and False)      # False
print(True or False)       # True
print(not True)            # False

# Преобразование к bool:
print(bool(""))            # False (пустая строка)
print(bool("text"))        # True  (непустая строка)
print(bool(0))             # False (равно нулю)
print(bool(42))            # True 
print(bool([]))            # False (пустой список)
print(bool([0]))           # True  (непустой список)

# Использование в условиях и циклах:
a = 10
if a > 0:
    print("a положительно")

count = 3
while count:
    print(count)
    count -= 1

'''

#NoneType
'''
# None — специальное значение в Python, означающее "отсутствие значения".

x = None  # переменная не содержит данных

# Проверка на None через оператор is:
if x is None:
    print("x пустой")

# None считается False в логическом контексте:
if not x:
    print("x воспринимается как False")

# при этом сравнение None с чем-либо даст False, только при сравнении с самой собой даст True

print(None == None)
print(None == 0)
print(None == False)

# Функции без return возвращают None по умолчанию.

'''

# set - множества  статья из хабра
'''
# МНОЖЕСТВА (set) в Python — краткий конспект с методами update

# --- Что такое множество ---
# Множество — неупорядоченная коллекция уникальных элементов.

# --- Создание ---
a = {1, 2, 3}
b = set([2, 3, 4])
empty = set()

# --- Добавление элементов ---
a.add(4)           # Добавляет один элемент
a.update([5, 6])   # Добавляет все элементы из итерируемого объекта по отдельности

# --- Объединение ---
# Возвращает новое множество:
c = a | b                  # Оператор объединения
c = a.union(b)             # Метод объединения

# Изменяет исходное множество:
a.update(b)                # Добавляет все элементы из b в a (аналог a = a | b)

# --- Пересечение ---
# Возвращает новое множество:
d = a & b                  # Оператор пересечения
d = a.intersection(b)      # Метод пересечения

# Изменяет исходное множество:
a.intersection_update(b)   # Оставляет в a только элементы, которые есть и в b

# --- Разность ---
# Возвращает новое множество:
e = a - b                  # Оператор разности
e = a.difference(b)        # Метод разности

# Изменяет исходное множество:
a.difference_update(b)     # Удаляет из a все элементы, которые есть в b

# --- Симметрическая разность ---
# Возвращает новое множество:
f = a ^ b                          # Оператор симметрической разности
f = a.symmetric_difference(b)      # Метод симметрической разности

# Изменяет исходное множество:
a.symmetric_difference_update(b)   # Оставляет в a только элементы, которые есть в одном из множеств, но не в обоих


# Методы удаления из множества
s = {1, 2, 3}

s.discard(2)  # удаляет 2, если есть, ошибки нет
s.remove(3)   # удаляет 3, если нет — ошибка KeyError
elem = s.pop()  # удаляет и возвращает случайный элемент, если пусто — ошибка
print(elem)
print(s)


# --- Примеры для сравнения методов ---
x = {1, 2, 3}
y = {3, 4, 5}

# Объединение:
print(x.union(y))    # {1, 2, 3, 4, 5} — новое множество
x.update(y)
print(x)             # {1, 2, 3, 4, 5} — x изменился

# Пересечение:
x = {1, 2, 3}
print(x.intersection(y))  # {3} — новое множество
x.intersection_update(y)
print(x)                  # {3} — x изменился

# Разность:
x = {1, 2, 3}
print(x.difference(y))    # {1, 2} — новое множество
x.difference_update(y)
print(x)                  # {1, 2} — x изменился

# Симметрическая разность:
x = {1, 2, 3}
print(x.symmetric_difference(y))    # {1, 2, 4, 5} — новое множество
x.symmetric_difference_update(y)
print(x)                           # {1, 2, 4, 5} — x изменился

# --- Кратко о методах с окончанием update ---
# ..._update методы изменяют исходное множество, а методы без update возвращают новое множество, не меняя исходное.


--- Таблица соответствия методов и операторов над множествами ---

A | B
A.union(B)
Возвращает множество, являющееся объединением множеств A и B

A |= B
A.update(B)
Добавляет в множество A все элементы из множества B

A & B
A.intersection(B)
Возвращает множество, являющееся пересечением множеств A и B

A &= B
A.intersection_update(B)
Оставляет в множестве A только те элементы, которые есть в множестве B

A - B
A.difference(B)
Возвращает разность множеств A и B

A -= B
A.difference_update(B)
Удаляет из множества A все элементы, входящие в B

A ^ B
A.symmetric_difference(B)
Возвращает симметрическую разность множеств A и B

A ^= B
A.symmetric_difference_update(B)
Записывает в A симметрическую разность множеств A и B


--- Таблица соответствия методов и операторов над множествами ---

set1 <= set2
set1.issubset(set2)
Возвращает True, если set1 является подмножеством set2

set1 >= set2
set1.issuperset(set2)
Возвращает True, если set1 является надмножеством set2

set1 < set2
Эквивалентно set1 <= set2 and set1 != set2 (строгое подмножество)

set1 > set2
Эквивалентно set1 >= set2 and set1 != set2 (строгое надмножество)

Для определения отсутствия общих элементов в множествах используется метод isdisjoint(). 
Данный метод возвращает значение True, если множества не имеют общих элементов, и  False, когда множества имеют общие элементы.
'''

# кортежи
'''
# --- Что такое кортеж ---
# Кортеж (tuple) — неизменяемая (immutable) последовательность элементов любого типа.
# После создания изменить его нельзя: нельзя добавить, удалить, заменить элементы.
# Поддерживает индексацию, срезы и перебор.

# --- Создание кортежей ---
t1 = ()                              # пустой кортеж
t2 = (42,)                           # кортеж из одного элемента (запятая обязательна!)
t3 = (1, "python", True)             # кортеж с разными типами
t4 = 1, 2, 3                         # скобки можно опустить
t5 = tuple([1, 2, 3])                # из другого итерируемого объекта

# --- Доступ, перебор, срезы ---
print(t3[0])                         # доступ по индексу
print(t3[1:3])                       # срез
for elem in t3:
    print(elem)                      # перебор

# --- Неизменяемость ---
# t3[0] = 99      # ОШИБКА: кортеж изменить нельзя
# t3.append(5)    # ОШИБКА: нет такого метода

# --- Исключение: изменяемые элементы внутри ---
t6 = ([1, 2], 3)
t6[0].append(4)                      # допустимо: теперь [1, 2, 4]
print(t6)                            # ([1, 2, 4], 3)

# --- Операции и функции ---
t7 = (1, 2, 3)
t8 = (4, 5)
print(t7 + t8)                       # (1, 2, 3, 4, 5) — объединение
print(t7 * 2)                        # (1, 2, 3, 1, 2, 3) — повторение
print(len(t7))                       # 3 — длина
print(2 in t7)                       # True — проверка наличия
print(sum(t7))                       # 6 — сумма, если элементы числовые
print(max(t7), min(t7))              # максимум, минимум

# --- Методы кортежей ---
t9 = (1, 2, 2, 3)
print(t9.count(2))                   # 2 — сколько раз встречается 2
print(t9.index(3))                   # 3 — индекс первого вхождения 3

# --- Распаковка (unpacking) ---
a, b = (10, 20)
print(a, b)                          # 10 20

m, *n = (1, 2, 3, 4)
print(m)                             # 1
print(n)                             # [2, 3, 4]

# --- Вложенные кортежи ---
nested = ((1, 2), (3, 4))

# --- Использование ---
# - Кортежи используют для хранения фиксированных наборов данных (например, координаты, RGB, отчёт по студенту и т.д.)
# - Можно использовать как ключ словаря, если все элементы — неизменяемые
d = { (1, 2): "point" }
print(d)

# --- Почему кортежи ---
# - Экономят память по сравнению со списками
# - Данные защищены от изменений
# - Можно использовать как ключи в dict и элементы множества (если элементы неизменяемы)

'''

# словари
'''
# --- 1. Основы словарей ---
# Словарь — коллекция пар "ключ: значение".
# Ключи: только неизменяемые типы (str, int, tuple).
# Значения: любые объекты.

# Создание словарей
empty_dict = {}                               # пустой словарь
example_dict = {'key1': 'value1', 'k2': 42}   # с начальными данными

# --- 2. Доступ и изменение элементов ---
d = {'a': 1, 'b': 2}
val1 = d['a']                # доступ по ключу (KeyError, если нет)
val2 = d.get('c', 0)         # безопасный доступ с default

d['c'] = 3                   # добавление/замена элемента
if 'b' in d:                 # проверка наличия ключа
    print('Есть!')

# --- 3. Удаление элементов ---
del d['a']                   # удалить по ключу (KeyError, если нет)
removed = d.pop('b', None)   # удалить и вернуть значение, или default

# --- 4. Основные методы dict ---
# Получение коллекций:
d.keys()     # все ключи (dict_keys)
d.values()   # все значения (dict_values)
d.items()    # пары (dict_items)

# Очистка словаря:
d.clear()

# Копирование:
copy_d = d.copy()            # поверхностная копия

# fromkeys:
new_d = dict.fromkeys(['x', 'y'], 0)  # {'x': 0, 'y': 0}

# setdefault — получить значение, если нет — создать:
z = d.setdefault('z', 100)

# update — добавить/обновить пары из другого dict/итератора:
other = {'e': 5}
d.update(other)

# popitem — удалить последнюю (Python 3.7+) добавленную пару:
k_v = d.popitem()

# --- 5. Итерация по словарю ---
for k in d:                  # по ключам
    print(k, d[k])

for v in d.values():         # по значениям
    print(v)

for k, v in d.items():       # по парам
    print(k, v)

# --- 6. dict generator: генераторы словарей ---
lst = ['a', 'b', 'c']
vals = [1, 2, 3]
d_comp = {k: v for k, v in zip(lst, vals)}          # {'a': 1, 'b': 2, 'c': 3}
filtered = {k: v for k, v in d.items() if v > 2}    # фильтрация по значениям

# --- 7. Объединение/слияние словарей ---
a = {'x': 1}
b = {'y': 2, 'x': 3}
merged = {**a, **b}             # Python 3.5+
merged2 = a | b                 # Python 3.9+

# При совпадении ключей берется значение второго dict

# --- 8. Особенности работы c dict ---
# - с Python 3.7 сохраняется порядок добавления ключей
# - ключи должны быть хешируемыми

# --- 9. Специализированные типы dict ---
from collections import defaultdict, Counter

dd = defaultdict(int)
dd['missing'] += 1              # автоматически 0+1

c = Counter(['a', 'a', 'b'])    # Counter({'a': 2, 'b': 1})

# --- 10. Примеры из курса ---

# 1. Словарь сленгов:
slang = {
    'bug': 'ошибка',
    'commit': 'фикс изменений',
    # ...
}
def get_slang(word):
    return slang.get(word, 'Неизвестно')

# 2. Генерация dict из строки:
s = '1:one 2:two 3:three'
res = {int(num): word for num, word in (item.split(':') for item in s.split())}
# {1: 'one', 2: 'two', 3: 'three'}

# --- 11. Краткое резюме ---
# - dict — основной тип для пар "ключ: значение"
# - доступ, добавление, удаление — быстро
# - методы: get, setdefault, pop, update, keys, values, items, popitem, clear, copy, fromkeys
# - поддержка генераторов и слияния
# - порядок ключей сохраняется (Py 3.7+)
# - ключи — только хешируемые объекты

'''

# random
'''
import random


random.seed(42)                              # Установка начального значения генератора (seed)

random.random()                              # Случайное float в диапазоне [0.0, 1.0)
random.uniform(a, b)                         # Случайное float в диапазоне [a, b]
random.randint(a, b)                         # Случайное целое число N, a ≤ N ≤ b
random.randrange(start, stop[, step])        # Случайное целое из range(start, stop, step)

random.choice(seq)                           # Случайный элемент из непустой последовательности
random.choices(seq, k)                       # Список из k элементов с возможными повторениями
random.sample(population, k)                 # Список из k уникальных элементов без повторений

random.shuffle(x)                            # Перемешать список x "на месте"

random.getstate()                            # Получить текущее состояние генератора
random.setstate(state)                       # Установить состояние генератора
random.seed(a=None)                          # Инициализация генератора (по умолчанию системное время)

random.normalvariate(mu, sigma)              # Число из нормального распределения с мат. ожиданием mu и сд sigma
random.lognormvariate(mu, sigma)             # Число из логнормального распределения с параметрами mu, sigma

# ---- Пример функции генерации случайного пароля ----
import string
def generate_password(length=8):
    chars = string.ascii_letters + string.digits
    return ''.join(random.choices(chars, k=length))
'''

# decimal (убийца float)
'''
# Decimal — точный десятичный тип, заменяющий float в точных вычислениях  
# Используйте Decimal(str) для создания из строк — избегайте float  
# Контекст (getcontext()) контролирует точность и поведение округления  
# as_tuple() возвращает внутреннее представление числа (sign, digits, exponent)  
# quantize() позволяет явно округлять числа по шаблону  
# Decimal умеет работать с бесконечностями и NaN  


from decimal import *

# --- 1. Зачем нужен decimal? ---
# float часто теряет точность из-за двоичного представления (например, 0.1+0.2 != 0.3)
# decimal работает с десятичной арифметикой точно, подходит для финансовых и научных расчётов.


# --- 2. Создание Decimal объектов ---
d_str = Decimal("0.1")      # Рекомендуемый способ — из строки для точности
d_int = Decimal(10)         # Из целого числа — также безопасно
d_float = Decimal(0.1)      # Нежелательно — создаст неточное значение из float

print(d_str)                # 0.1
print(d_float)              # 0.1000000000000000055511151231257827021181583404541015625

# --- 3. Контекст decimal ---
# Контекст управляет:
# - точностью (количеством значащих цифр)
# - правилами округления
# - ошибками и предупреждениями во время вычислений

ctx = getcontext()
print(ctx)                  # Печать текущих настроек контекста

ctx.prec = 6                # Задаём точность — число значащих цифр
ctx.rounding = ROUND_HALF_EVEN  # Метод округления (округление до ближайшего чётного)

# Пример:
print(Decimal("1") / Decimal("7"))  # Вывод с 6 знаками точности


# --- 4. Основные арифметические операции с Decimal ---
a = Decimal("1.1")
b = Decimal("2.2")

print(a + b)    # сложение       -> 3.3
print(b - a)    # вычитание      -> 1.1
print(a * b)    # умножение      -> 2.42
print(b / a)    # деление       -> 2.000000 (с учетом точности ctx.prec)

# --- Функции Decimal для математических операций ---
d = Decimal("16")

print(d.sqrt())    # квадратный корень — 4
print(d.exp())     # e^16 — экспонента (e ~ 2.718)
print(d.ln())      # натуральный логарифм ln(16)
print(d.log10())   # десятичный логарифм log10(16)


# --- 5. Метод as_tuple() ---
# Возвращает именованный кортеж DecimalTuple с полями:
#   sign — 0 (положительное) или 1 (отрицательное)
#   digits — кортеж цифр числа без десятичной точки
#   exponent — значение экспоненты (количество цифр после точки, умноженное на −1)

d = Decimal("-123.45")
t = d.as_tuple()

print(t)  
# DecimalTuple(sign=1, digits=(1, 2, 3, 4, 5), exponent=-2)

# Это структура числа, полезна для глубокого анализа или сериализации.


# --- 6. Округление  ---
d2 = Decimal("2.34567")

rounded_2d = d2.quantize(Decimal("0.01"))    # Округление до сотых: 2.35
rounded_1d = d2.quantize(Decimal("0.1"))     # Округление до десятых: 2.3

print(rounded_2d)
print(rounded_1d)

#Помимо первого параметра, метод quantize() принимает в качестве второго параметра стратегию округления:
num = Decimal("6.565")
fmt = Decimal("0.1")  # округление до десятых

print(num.quantize(fmt, rounding=ROUND_CEILING))   # к +∞ (6.6)   – округление в направлении бесконечности (Infinity);
print(num.quantize(fmt, rounding=ROUND_FLOOR))     # к -∞ (6.5)   – округляет в направлении минус бесконечности (- Infinity);
print(num.quantize(fmt, rounding=ROUND_DOWN))      # к 0 (6.5)    – округление в направлении нуля;
print(num.quantize(fmt, rounding=ROUND_HALF_EVEN)) # ближайшее чётное (6.6)   – округление до ближайшего четного числf;
print(num.quantize(fmt, rounding=ROUND_HALF_DOWN)) # к 0, если ровно посередине (6.5)     – округление до ближайшего нуля;
print(num.quantize(fmt, rounding=ROUND_UP))        # от 0 (6.6)             – округление от нуля;
print(num.quantize(fmt, rounding=ROUND_05UP))      # от 0 при 0 или 5 в конце (6.6)  – округление от нуля (если последняя цифра после округления до нуля была бы 0 или 5, в противном случае – к нулю).



# --- 7. Специальные значения ---
inf = Decimal("Infinity")          # + бесконечность
ninfinity = Decimal("-Infinity")   # - бесконечность
nan = Decimal("NaN")               # не число

print(inf, ninfinity, nan)


# --- 8. Создание и настройка контекста (без with) ---
my_ctx = Context(prec=10, rounding=ROUND_HALF_EVEN)
print(my_ctx)

# Использование собственного контекста:
res = Decimal("1") / Decimal("3")
print(res)   # Деление с текущей точностью контекста getcontext()


# --- 9. Пример практического использования: финансовые вычисления ---

price = Decimal("19.99")
quantity = Decimal("3")
total = price * quantity

# Округляем сумму до двух знаков после запятой (центов)
total_rounded = total.quantize(Decimal("0.01"))

print(f"Итоговая сумма: {total_rounded}")

'''

# fractions (рациональные числа)
'''
from fractions import Fraction
from decimal import Decimal

# --- 1. Назначение ---
# Модуль fractions обеспечивает поддержку арифметики рациональных чисел.
# Класс Fraction представляет простую дробь с числителем и знаменателем.

# --- 2. Создание экземпляров Fraction ---

# Из числителя и знаменателя (по умолчанию 0/1):
f1 = Fraction()              # Fraction(0, 1)
f2 = Fraction(1, 2)         # 1/2
f3 = Fraction(2, 4)         # сократится до 1/2

# Можно использовать именованные аргументы:
f4 = Fraction(numerator=3, denominator=6)  # тоже 1/2

# Из целого числа (знаменатель = 1):
f5 = Fraction(5)            # 5/1

# Из float — осторожно, возможна неточность:
f6 = Fraction(1.5)          # Fraction(3, 2)

# Из Decimal — точное преобразование:
f7 = Fraction(Decimal('1.5'))  # Fraction(3, 2)

# Из строки:
f8 = Fraction('3/4')
f9 = Fraction('1.2')        # 6/5
f10 = Fraction('1.2e2')     # 120/1

# --- 3. Собственные свойства Fraction ---

print(f2.numerator)          # числитель, 1
print(f2.denominator)        # знаменатель, 2

# --- 4. Арифметика с Fraction ---

a = Fraction(3, 4)
b = Fraction(1, 2)

print(a + b)    # 5/4
print(a - b)    # 1/4
print(a * b)    # 3/8
print(a / b)    # 3/2
print(a ** 2)   # 9/16

# --- 5. Преобразование в другие типы ---

print(int(a))      # 0 — целочисленное округление вниз
print(float(a))    # 0.75
print(str(a))      # "3/4"

# --- 6. Сравнение поддерживается ---

print(Fraction(1, 2) == 0.5)    # True
print(Fraction(1, 2) < Fraction(3,4))  # True

# --- 7. Взаимодействие с числами float и Decimal ---

# Рациональные числа можно свободно использовать со float, но не с Decimal напрямую:
print(Fraction(3,4) + 0.5)     # Работает, результат Fraction(5/4)
# print(Fraction(3,4) + Decimal('0.5'))  # Ошибка TypeError

# --- 8. Полезные методы ---

# limit_denominator(max_denominator) — приближает дробь к с максимально допустимым знаменателем
f = Fraction(1.1)
print(f)                        # Может быть представлено неточно
print(f.limit_denominator(10)) # Приближённое значение с max знаменателем 10

# --- 9. Использование с math-модулем ---

# Fraction можно передавать большинству функций math после преобразования в float
import math
x = Fraction(1,3)
print(math.sqrt(float(x)))      # Корень из 1/3

# --- 10. Особенности и ограничения ---

# Fraction объекты неизменяемы и хешируемы
# Параметры числителя и знаменателя автоматически сокращаются через НОД

# --- 11. Пример использования ---

from fractions import Fraction

def add_fractions(frac1, frac2):
    f1 = Fraction(frac1)
    f2 = Fraction(frac2)
    return f1 + f2

print(add_fractions('3/4', '2/5'))   # 23/20
'''

# тип данных Complex (комплЕксный)
'''
# --- 1. Что такое complex? ---
# complex — встроенный тип данных Python для представления комплексных чисел.
# Комплексное число имеет вид: z = a + bj,
# где a — действительная часть (real),
# b — мнимая часть (imag),
# j (или J) — мнимая единица, квадрат которой равен -1. 

# - complex поддерживает арифметические операции +, -, *, /, возведение в степень и др.
# - имеет свойства .real и .imag для доступа к частям
# - модуль числа рассчитывается через abs()
# - создание через complex(real, imag), строку или литерально с j
# - не поддерживает операторы сравнения (<, >), но поддерживает == и !=
# - полезен при решении задач, связанных с комплексными числами, электрическими цепями, сигналами и др.


# --- 2. Создание комплексных чисел ---

# 2.1 С помощью функции complex(real=0, imag=0)
z1 = complex()            # (0+0j) — по умолчанию ноль
z2 = complex(5)           # (5+0j) — только действительная часть
z3 = complex(3, 4)        # (3+4j) — действительная и мнимая части

# 2.2 Создание из строки
z4 = complex('1+2j')      # (1+2j), строка должна иметь формат 'a+bj'

# 2.3 Литеральный синтаксис
z5 = 2 + 3j               # (2+3j) — можно создавать напрямую

# --- 3. Свойства комплексных чисел ---

print(z3.real)            # Действительная часть: 3.0
print(z3.imag)            # Мнимая часть: 4.0

# --- 4. Основные операции с complex ---

a = complex(1, 2)         # (1+2j)
b = complex(3, 4)         # (3+4j)

print(a + b)              # сложение: (4+6j)
print(a - b)              # вычитание: (-2-2j)
print(a * b)              # умножение: (-5+10j)
print(a / b)              # деление: (0.44+0.08j)

# Модуль (длина комплексного числа)
print(abs(a))             # sqrt(1^2 + 2^2) = 2.236...

# Возведение в степень
print(pow(a, 2))          # (1+2j)^2 = (-3+4j)

# Сопряжённое число
print(a.conjugate())      # (1-2j)

# --- 5. Ограничения ---

# Комплексные числа нельзя упорядочивать (нет операторы <, > и т.п.)
# Попытка сравнить вызовет TypeError:
# print(a > b)  # Ошибка

# Но сравнение на равенство и неравенство поддерживается
print(a == b)             # False
print(a == complex(1, 2)) # True

# --- 6. Преобразования и типы ---

# Можно создавать complex из int, float или строки
z6 = complex(3.5, 2.1)
z7 = complex('10-5j')

# --- 7. Пример использования ---

def complex_operations(x, y):
    z = complex(x, y)
    print("Число:", z)
    print("Действительная часть:", z.real)
    print("Мнимая часть:", z.imag)
    print("Модуль числа:", abs(z))
    print("Квадрат:", z ** 2)
    print("Сопряжённое:", z.conjugate())

complex_operations(2, 3)
'''

# Turtle (черепашка)
'''
from turtle import *

# Движение и повороты
forward(длина)         # вперёд
backward(длина)        # назад
right(угол)            # вправо на угол (градусы)
left(угол)             # влево на угол
goto(x, y)             # }
setpos(x, y)           # } } перейти в точку с координатами (x, y)
setposition(x, y)      # }        
setx(x)                # изменить только x
sety(y)                # изменить только y
setheading(угол)       # установить направление (0 – вправо, 90 – вверх)

# Состояние и позиция
pos()                  # } } получить (x, y)
position()             # }
xcor()                 # только x
ycor()                 # только y
heading()              # получить текущий угол

# Перо и заливка
penup(), up()          # поднять перо (движение без линии)
pendown(), down()      # опустить перо (движение с линией)
pensize(толщина)       # ширина линии
pencolor('цвет')       # цвет линии
fillcolor('цвет')      # цвет заливки
begin_fill()           # начать заливку
end_fill()             # закончить заливку
isdown()               # True, если перо опущено

# Внешний вид и фон
color('цвет')          # сразу установить цвет линии и заливки
bgcolor('цвет')        # цвет фона окна
shape('turtle')        # внешний вид (например: ‘turtle’, ‘arrow’, etc.)
shapesize(w, h)        # масштаб черепахи
speed(число)           # скорость 0–10
title('Заголовок')     # заголовок окна
hideturtle()           # скрыть черепаху
showturtle()           # показать черепаху

screen = turtle.Screen()       # создаём объект экрана
screen.bgcolor("orange")       # устанавливаем цвет фона через объект
Screen().setup(400, 400)               # устанавливаем размер граф. окна
Screen().addshape('rocketship.png')    # добавляем форму черепашки
Screen().bgpic('space.jpg')            # устанавливаем фоновое изображение
shape('rocketship.png')                # устанавливаем форму черепашки


# Очистка и сброс
clear()                # стереть линии (курсора не сбрасывает)
reset()                # очистить поле и сбросить курсор
clearscreen()          # очистить всё окно и сбросить всё

# Графические действия
circle(radius, extent=None, steps=None)  # окружность или дуга
dot(size, color)       # точка
stamp()                # отпечатать форму черепахи
undo()                 # шаг назад

# Клонирование
clone()                # создать копию черепахи

# Управление состояниями и видимостью
tracer(n)              # ускорить рисование (0 – без анимации)
update()               # обновить экран при tracer(0)
settiltangle(угол)     # наклонить форму
tilt(угол)             # повернуть форму относительно направления

# События и взаимодействие (ввод)
onclick(функция)       # действие по клику
onkey(функция, 'клавиша')  # обработка клавиши

# Завершение работы
done()                 # держать окно открытым

# Краткий пример любого многоугольника:
for _ in range(5):
    forward(100)
    left(72)
done()


# ТЕКСТ
# write(arg, move=False, align='left', font=('Arial',12,'normal'))
# arg – текст или число
# move – True – переместить черепаху после записи
# align – выравнивание: 'left', 'center', 'right'
# font – шрифт: (название, размер, стиль), стиль может быть 'normal', 'bold', 'italic', 'bold italic'
write('Привет!', move=False, align='center', font=('Arial', 14, 'bold italic'))

# Несколько черепах:
t1 = Turtle()
t2 = Turtle()
t1.color('red')
t2.color('blue')
t1.forward(100)
t2.left(90)
t2.forward(50)

# Управление анимацией:
tracer(n=1, delay=10)  
# n – обновления экрана каждый n-й шаг (0 – мгновенно)
# delay – задержка в миллисекундах между обновлениями
# При tracer(0) после команд нужен update()

# Работа с клавиатурой:
screen = Screen()
screen.listen()           # активирует "слушание" клавиатурных событий для текущего окна.
# Если не вызвать listen(), то нажатие на клавиши не будет вызывать функции.

def move_up():
    t1.forward(50)

screen.onkey(move_up, 'Up')  # вызвать move_up при нажатии стрелки вверх

# Проверка видимости:
print(t1.isvisible())     # True — если черепаха видна

# Обработка клика по черепахе:
def on_click(x, y):
    print(f'Клик по: {x}, {y}')

t1.onclick(on_click)      # вызов on_click при клике по t1

'''

# Функции (args,kwargs ; map,filter,reduce ; парадигмы функций ; all,any,enumerate,zip)
'''

# --- 1. Определение функции и параметры по умолчанию (defaults) ---
def greet(name="Гость"):
    print(f"Привет, {name}!")

greet()            # Привет, Гость!
greet("Маша")      # Привет, Маша!



# --- 2. Аргументы *args и **kwargs ---
def func_args_kwargs(*args, **kwargs):
    print("args:", args)        # кортеж позиционных аргументов
    print("kwargs:", kwargs)    # словарь именованных аргументов

func_args_kwargs(1, 2, 3, a=10, b=20)



# --- 3. Функции как объекты ---
def f(x):
    return x + 1

g = f         # присваиваем функцию переменной
print(g(5))   # 6



# --- 4. Вложенные функции и замыкания ---
def outer(x):
    def inner(y):
        return x + y
    return inner

f1 = outer(10)
print(f1(5))  # 15 (inner замкнула значение x из outer)



# --- 5. Функции первого и высшего порядка ---
# Функция первого порядка - просто функция.
# Функция высшего порядка - функция, принимающая или возвращающая другую функцию.

def apply_func(func, value):
    return func(value)

print(apply_func(lambda x: x*2, 10))  # 20



# --- 6. map, filter, reduce – итераторы ---

numbers = [1, 2, 3, 4, 5]

# map(func, iterable)
# Применяет функцию к каждому элементу и возвращает итератор с результатами.
mapped = map(lambda x: x * 2, numbers)
print(list(mapped))  # Преобразуем итератор в список: [2, 4, 6, 8, 10]

# filter(func, iterable)
# Фильтрует элементы по условию и возвращает итератор отфильтрованных элементов.
filtered = filter(lambda x: x % 2 == 0, numbers)
print(list(filtered))  # [2, 4]

from functools import reduce
# reduce(func, iterable[, initializer])
# Применяет функцию с накоплением к элементам по порядку, возвращает одно значение.
reduced = reduce(lambda x, y: x + y, numbers)
print(reduced)  # 15

# Итератор — объект, который генерирует элементы по одному за раз при итерации.
# Итераторы экономят память при работе с большими данными, потому что не хранят весь результат в памяти.
# Чтобы получить все значения из итератора, используйте list(), цикл for или другие конструкторы.



# --- 9. all, any, enumerate, zip ---

# all — True, если все элементы истинны
print(all([True, 1, "text"]))       # True

# any — True, если хотя бы один элемент истинен
print(any([False, 0, "", 7]))       # True

# enumerate — нумерует итерируемый объект, возвращая (индекс, элемент)
for i, v in enumerate(['a', 'b', 'c']):
    print(i, v)
# 0 a
# 1 b
# 2 c

# zip — объединяет 2 и более итерируемых переменных в кортежи по индексам
a = [1, 2, 3]
b = ['x', 'y', 'z']
print(list(zip(a, b)))  # [(1, 'x'), (2, 'y'), (3, 'z')]




# --- Парадигмы программирования (кратко) ---

# 1) Процедурное
# - Программа — набор процедур (функций), выполняющихся последовательно.
# - Акцент на шаги и порядок выполнения.

# 2) Объектно-ориентированное (ООП)
# - Всё — объекты с состоянием и методами.
# - Основы: инкапсуляция, наследование, полиморфизм.
# - Удобно для моделирования сложных систем.

# 3) Функциональное
# - Основной инструмент — чистые функции без побочных эффектов.
# - Используются функции высшего порядка, лямбды, рекурсия.
# - Код более предсказуемый и параллельный.

# 4) Логическое
# - Описывает программу через факты и правила.
# - Подход “что” вычислять, а не “как”.
# - В Python поддерживается частично.

# 5) Событийно-ориентированное
# - Программа реагирует на события (клики, сообщения).
# - Используются обработчики событий и callback-функции.


'''

# Модуль operator
'''
import operator

# Арифметика
operator.add(a, b)       # a + b
operator.sub(a, b)       # a - b
operator.mul(a, b)       # a * b
operator.truediv(a, b)   # a / b (деление с плавающей точкой)
operator.floordiv(a, b)  # a // b (целочисленное деление)
operator.mod(a, b)       # a % b (остаток от деления)
operator.pow(a, b)       # a ** b

# Логические операции
operator.and_(a, b)      # a & b (побитовое И)
operator.or_(a, b)       # a | b (побитовое ИЛИ)
operator.xor(a, b)       # a ^ b (побитовое исключающее ИЛИ)
operator.not_(a)         # побитовое НЕ

# Сравнения
operator.eq(a, b)        # a == b
operator.ne(a, b)        # a != b
operator.lt(a, b)        # a < b
operator.le(a, b)        # a <= b
operator.gt(a, b)        # a > b
operator.ge(a, b)        # a >= b

# Доступ к элементам и атрибутам
operator.getitem(obj, key)       # obj[key]
operator.setitem(obj, key, val)  # obj[key] = val
operator.delitem(obj, key)       # del obj[key]
operator.attrgetter(attr)        # получение атрибута
operator.itemgetter(n)           # получение элемента по индексу

# Функции для вызова других функций
operator.methodcaller(name, *args, **kwargs) # вызов метода с заданными аргументами

'''

# Работа с файлами
'''
# --- 1. Открытие файла: функция open() и режимы доступа ---

# Синтаксис:
# open(filename, mode='r', encoding=None)
# - filename — имя файла (путь)
# - mode — режим:
#   'r'  — чтение (по умолчанию), файл должен существовать
#   'w'  — запись, очищает или создаёт файл
#   'a'  — добавление (append), пишет в конец
#   'x'  — создать только новый файл (ошибка, если уже есть)
#   'b'  — бинарный режим (добавляется к другим, например 'rb', 'wb')
#   '+'  — обновление (чтение и запись, например 'r+', 'w+')
# - encoding — кодировка (важно для текстовых файлов, например 'utf-8')

file = open('file.txt', 'r', encoding='utf-8')

# После работы с файлом его нужно обязательно закрыть:
file.close()
# Иначе могут возникнуть ошибки или потеря данных.
# Чтобы не забывать закрывать, лучше использовать менеджер контекста (with).


# --- 2. Менеджер контекста for file handling ---

# Автоматически откроет и закроет файл после блока
with open('file.txt', 'r', encoding='utf-8') as f:
    data = f.read()

# --- 3. Основные файловые методы ---

# Чтение
f.read(n=-1)          # прочитать n символов/байт, если n не указан — весь файл
f.readline()          # прочитать одну строку (включая \n)
f.readlines()         # прочитать все строки в список

# Запись
f.write(string)       # записать строку (возвращает кол-во записанных символов)
f.writelines(list_of_strings)  # записать последовательность строк (без автоматических \n)

# Позиционирование в файле
f.seek(offset, whence=0)
# - offset — смещение (число)
# - whence — стартовая точка (0 — начало файла, 1 — текущая позиция, 2 — конец)

f.tell()
# - возвращает текущую позицию в файле (число байт или символов от начала)

# --- 4. Дополнительные моменты ---

# При открытии в 'r' без 'b' возвращается текст (str), в 'rb' — байты (bytes)
# Запись и чтение должны совпадать по типу (если бинарный режим, передайте байты)

# Пример записи и чтения:
with open('example.txt', 'w', encoding='utf-8') as f:
    f.write("Привет!\nКак дела?")

with open('example.txt', 'r', encoding='utf-8') as f:
    print(f.readline())  # 'Привет!\n'
    print(f.tell())      # Позиция после первой строки
    f.seek(0)            # Вернуться в начало файла
    all_text = f.read()

# --- Итог ---

# - use open() с нужным режимом и encoding
# - обязательно закрывать файл: лучше с менеджером контекста with
# - для чтения:
#       read() — вся строка
#       readline() — строка
#       readlines() — список строк
# - для записи:
#       write() — строка
#       writelines() — несколько строк
# - seek() и tell() — для работы с текущей позицией в файле

'''
































# задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи задачи

# Задача Иосифа Флавия (так и не понял)
# моё супер запутанное недоделанное решение
"""
n,k = 40,4
numbers = [i for i in range(1,n+1)]
i = 0

while numbers.count(0) != n-1: #пока не остались все нули кроме 1 числа
    print(numbers)

    j = i-1    #запоминаем индекс прошлого числа

    print(j,i)

    if (i+k)%n != 0:   #находим новое число (не индекс). делаем шаг
        i = (i+k)%n
    else:
        i = n

    if j != 39:

        if '0' in numbers[j+1:i-1]:
            num = set(numbers[j+1:i-1])
            num.remove(0)
            while len(num) != k-1:   #между старым и новым индексом должно быть 3 играющие цифры

                if (i+1)%n != 0:   #находим новое число (не индекс). делаем шаг
                    i = (i+1)%n

                else:
                    i = n

        else:

            while len(set(numbers[j+1:i-1])) != k-1:   #между старым и новым индексом должно быть 3 играющие цифры
                if (i+1)%n != 0:   #находим новое число (не индекс). делаем шаг
                    i = (i+1)%n
                else:
                    i = n

    else:

        if '0' in numbers[j+1:] and '0' in numbers[:i-1]:
            num1 = set(numbers[j+1:])
            num1.remove(0)
            num2 = set(numbers[:i-1])
            num2.remove(0)
            while len(num1) + len(num2) != k-1:   #между старым и новым индексом должно быть 3 играющие цифры
                if (i+1)%n != 0:   #находим новое число (не индекс). делаем шаг
                    i = (i+1)%n
                else:
                    i = n

        elif '0' in numbers[j+1:]:
            num1 = set(numbers[j+1:])
            num1.remove(0)
            while len(num1) + len(set(numbers[:i-1])) != k-1:   #между старым и новым индексом должно быть 3 играющие цифры
                if (i+1)%n != 0:   #находим новое число (не индекс). делаем шаг
                    i = (i+1)%n
                else:
                    i = n

        elif '0' in numbers[:i-1]:
            num2 = set(numbers[:i-1])
            num2.remove(0)
            while len(set(numbers[j+1:])) + len(num2) != k-1:   #между старым и новым индексом должно быть 3 играющие цифры
                if (i+1)%n != 0:   #находим новое число (не индекс). делаем шаг
                    i = (i+1)%n
                else:
                    i = n

        else:
            while len(set(numbers[j+1:])) + len(set(numbers[:i-1])) != k-1:   #между старым и новым индексом должно быть 3 играющие цифры
                if (i+1)%n != 0:   #находим новое число (не индекс). делаем шаг
                    i = (i+1)%n
                else:
                    i = n

    if numbers[i-1] == 0:
        i+=1
        numbers[i-1] = 0
    else:
        numbers[i-1] = 0


print(numbers)
"""
# решение которое все обсуждают и единицы только поняли как оно работает
"""
n,k=int(input()),int(input())
res=0
for i in range(1,n+1):
    res = (res+k)%i
print(res+1)
"""

#Напишите программу для определения, является ли число произведением двух чисел из данного набора.
'''
n = int(input())
s = [int(input()) for i in range(n)]
s.sort()
a = int(input())
flag = False

for i in range(len(s)):
    ss = s.copy()
    del ss[i]
    
    if s[i] * ss[len(ss)//2] < a:
        for j in range( (len(ss)//2)+1 , len(ss) ):
            if s[i] * ss[j] == a:
                print('ДА')
                flag = True
                break
    
    else:
        for j in range( len(ss)//2 , -1 , -1 ):
            if s[i] * ss[j] == a:
                print('ДА')
                flag = True
                break
                
    if flag == True:
        break

if flag == False:
    print('НЕТ')

'''

# Модуль 15.5
# 12
"""
def reduce(operation, items, initial_value):
    acc = initial_value
    for item in items:
        acc = operation(acc, item)
    return acc


def square(x,y):
    return x + y**2


def square2(x):
    return x**2


numbers = [97, 42, 9, 32, 3, 45, 31, 77, -1, 11, -2, 75, 5, 51, 34, 28, 46, 1, -8, 84, 16, 51, 90, 56, 65, 90, 23, 35, 11, -10, 70, 90, 90, 12, 96, 58, -8, -4, 91, 76, 94, 60, 72, 43, 4, -6, -5, 51, 58, 60, 30, 38, 67, 62, 36, 72, 34, 82, 62, -1, 60, 82, 87, 81, -7, 57, 26, 36, 17, 43, 80, 40, 75, 94, 91, 64, 38, 72, 29, 84, 38, 35, 7, 54, 31, 95, 78, 27, 82, 1, 64, 94, 31, 29, -8, 98, 24, 61, 7, 73]

print(reduce(square,numbers,0))
print(sum(map(square2, numbers)))
"""
# 13
"""
def map(function, items):
    result = []
    for item in items:
        result.append(function(item))
    return result


def filter(function, items):
    result = []
    for item in items:
        if function(item):
            result.append(item)
    return result


def square(x):
    return x**2


def condition(x):
    return abs(x)%7==0 and 10<=abs(x)<=99


numbers = [77, 293, 28, 242, 213, 285, 71, 286, 144, 276, 61, 298, 280, 214, 156, 227, 228, 51, -4, 202, 58, 99, 270, 219, 94, 253, 53, 235, 9, 158, 49, 183, 166, 205, 183, 266, 180, 6, 279, 200, 208, 231, 178, 201, 260, -35, 152, 115, 79, 284, 181, 92, 286, 98, 271, 259, 258, 196, -8, 43, 2, 128, 143, 43, 297, 229, 60, 254, -9, 5, 187, 220, -8, 111, 285, 5, 263, 187, 192, -9, 268, -9, 23, 71, 135, 7, -161, 65, 135, 29, 148, 242, 33, 35, 211, 5, 161, 46, 159, 23, 169, 23, 172, 184, -7, 228, 129, 274, 73, 197, 272, 54, 278, 26, 280, 13, 171, 2, 79, -2, 183, 10, 236, 276, 4, 29, -10, 41, 269, 94, 279, 129, 39, 92, -63, 263, 219, 57, 18, 236, 291, 234, 10, 250, 0, 64, 172, 216, 30, 15, 229, 205, 123, -105]

print(sum(map(square, filter(condition, numbers))))
"""
# 14
"""
def func_apply(func, lst):
        res = []
        for item in lst:
                res.append(func(item))
        return res
"""

# Модуль 15.8
# 10
"""
numbers = [46, 61, 34, 17, 56, 26, 93, 1, 3, 82, 71, 37, 80, 27, 77, 94, 34, 100, 36, 81, 33, 81, 66, 83, 41, 80, 80, 93, 40, 34, 32, 16, 5, 16, 40, 93, 36, 65, 8, 19, 8, 75, 66, 21, 72, 32, 41, 59, 35, 64, 49, 78, 83, 27, 57, 53, 43, 35, 48, 17, 19, 40, 90, 57, 77, 56, 80, 95, 90, 27, 26, 6, 4, 23, 52, 39, 63, 74, 15, 66, 29, 88, 94, 37, 44, 2, 38, 36, 32, 49, 5, 33, 60, 94, 89, 8, 36, 94, 46, 33]
new_numbers = list(filter(lambda x: not(x>47 and x%2==1), numbers))
print(*map(lambda x: x//2 if x%2==0 else x, new_numbers))
"""
# 11
"""
data = [(19542209, 'New York'), (4887871, 'Alabama'), (1420491, 'Hawaii'), (626299, 'Vermont'), (1805832, 'West Virginia'), (39865590, 'California'), (11799448, 'Ohio'), (10711908, 'Georgia'), (10077331, 'Michigan'), (10439388, 'Virginia'), (7705281, 'Washington'), (7151502, 'Arizona'), (7029917, 'Massachusetts'), (6910840, 'Tennessee')]
new_data = sorted(data, reverse=True, key=lambda S: S[1][-1] )
[print(f"{S[1]}: {S[0]}") for S in new_data]
"""
# 12
"""
data = ['год', 'человек', 'время', 'дело', 'жизнь', 'день', 'рука', 'раз', 'работа', 'слово', 'место', 'лицо', 'друг', 'глаз', 'вопрос', 'дом', 'сторона', 'страна', 'мир', 'случай', 'голова', 'ребенок', 'сила', 'конец', 'вид', 'система', 'часть', 'город', 'отношение', 'женщина', 'деньги']
new_data = sorted(sorted(data), key=lambda s: len(s))
print(*new_data)
"""
# 13
"""
mixed_list = ['tuesday', 'abroad', 'abuse', 'beside', 'monday', 'abate', 'accessory', 'absorb', 1384878, 'sunday', 'about', 454805, 'saturday', 'abort', 2121919, 2552839, 977970, 1772933, 1564063, 'abduct', 901271, 2680434, 'bicycle', 'accelerate', 1109147, 942908, 'berry', 433507, 'bias', 'bestow', 1875665, 'besides', 'bewilder', 1586517, 375290, 1503450, 2713047, 'abnormal', 2286106, 242192, 701049, 2866491, 'benevolent', 'bigot', 'abuse', 'abrupt', 343772, 'able', 2135748, 690280, 686008, 'beyond', 2415643, 'aboard', 'bet', 859105, 'accident', 2223166, 894187, 146564, 1251748, 2851543, 1619426, 2263113, 1618068, 'berth', 'abolish', 'beware', 2618492, 1555062, 'access', 'absent', 'abundant', 2950603, 'betray', 'beverage', 'abide', 'abandon', 2284251, 'wednesday', 2709698, 'thursday', 810387, 'friday', 2576799, 2213552, 1599022, 'accept', 'abuse', 'abound', 1352953, 'bid', 1805326, 1499197, 2241159, 605320, 2347441]
new_mixed_list = max(mixed_list, key=lambda x: [0,x][type(x) is int])
print(new_mixed_list)
"""
# 14
"""
mixed_list = ['beside', 48, 'accelerate', 28, 'beware', 'absorb', 'besides', 'berry', 15, 65, 'abate', 'thursday', 76, 70, 94, 35, 36, 'berth', 41, 'abnormal', 'bicycle', 'bid', 'sunday', 'saturday', 87, 'bigot', 41, 'abort', 13, 60, 'friday', 26, 13, 'accident', 'access', 40, 26, 20, 75, 13, 40, 67, 12, 'abuse', 78, 10, 80, 'accessory', 20, 'bewilder', 'benevolent', 'bet', 64, 38, 65, 51, 95, 'abduct', 37, 98, 99, 14, 'abandon', 'accept', 46, 'abide', 'beyond', 19, 'about', 76, 26, 'abound', 12, 95, 'wednesday', 'abundant', 'abrupt', 'aboard', 50, 89, 'tuesday', 66, 'bestow', 'absent', 76, 46, 'betray', 47, 'able', 11]
print(*sorted(mixed_list, key=lambda x: (isinstance(x, str), x)))

"""
# 15
"""
s = input().split()
print(*list(map(lambda x: 255-int(x), s)))
"""
# 16
"""
from functools import reduce


def evaluate(lst, grade):
    
    def eva(x):
        return reduce(lambda x,y: x+y, (map(lambda a, b:  a*x**b , lst, grade)))
    
    return eva


lst = [int(x) for x in input().split()]
grade = list(range(len(lst)-1,-1,-1))
f = evaluate(lst, grade)

print(f(int(input())))
"""
# Модуль 15.9
# 9
"""
countries = ['Russia', 'USA', 'UK', 'Germany', 'France', 'India']
capitals = ['Moscow', 'Washington', 'London', 'Berlin', 'Paris', 'Delhi']
population = [145_934_462, 331_002_651, 80_345_321, 67_886_011, 65_273_511, 1_380_004_385]

res = list(zip(countries,capitals,population))

[print(f'{res[i][0]} is the capital of {res[i][1]}, population equal {res[i][2]} people.') for i in range(len(res))]
"""
# 10
"""
from decimal import Decimal as D

abscissas = [D(x) for x in input().split()]
ordinates = [D(x) for x in input().split()]
applicates = [D(x) for x in input().split()]

points = list(zip(abscissas,ordinates,applicates))

print(all([points[i][0]**2 + points[i][1]**2 + points[i][2]**2 <= 4 for i in range(len(points))]))
"""
# 11
"""
print(all([x.isdigit() and 0<=int(x)<=255 for x in input().split('.')]))
"""
# 12
"""
[print(i, end=' ') if '0' not in str(i) and all([i%int(j)==0 for j in str(i)]) else print('', end='') for i in range(int(input()), int(input())+1)]
"""
# 13
"""
import string

s = input()
print(['NO','YES'][all([len(s)>=7, 
                        any([char in string.digits for char in s]), 
                        any([char in string.ascii_lowercase for char in s]), 
                        any([char in string.ascii_uppercase for char in s])
                        ])])
"""
# 14
"""
n = int(input())
res = []

for _ in range(n):
    for_any = []
    for _ in range(int(input())):
        for_any.append(input().split()[1] == '5')
    res.append(any(for_any))
print(['NO','YES'][all(res)])
"""
# Модуль 16.1
# 16
"""
def pretty_print(data, side='-', delimiter='|'):
    stroka2 = str()
    for S in data:
        stroka2 += delimiter + ' ' + str(S) + ' '
    stroka2 += delimiter
    stroka1 = ' ' + side*(len(stroka2)-2) + ' '
    stroka3 = stroka1
    print(stroka1)
    print(stroka2)
    print(stroka3)

pretty_print([1, 2, 10, 23, 123, 3000])
"""
# Модуль 16.3
# 1
"""
def concat(*args, sep=' '):
    return sep.join(map(str,args))



print(concat('hello', 'python', 'and', 'stepik'))
print(concat('hello', 'python', 'and', 'stepik', sep='*'))
print(concat('hello', 'python', sep='()()()'))
print(concat('hello', sep='()'))
print(concat(1, 2, 3, 4, 5, 6, 7, 8, 9, sep='$$'))
"""
# 2
"""
from functools import reduce

def product_of_odds(data):
    result = 1
    result = reduce(lambda x,y:x*y, filter(lambda x: x%2==1,data), 1)
    return result
"""
# 3
"""
words = 'the world is mine take a look what you have started'.split()

print(*list(map(lambda s: f'"{s}"',words)))
"""
# 4
"""
numbers = [18, 191, 9009, 5665, 78, 77, 45, 23, 19991, 908, 8976, 6565, 5665, 10, 1000, 908, 909, 232, 45654, 786]
print(*filter(lambda s: str(s)!=str(s)[::-1], numbers))
"""
# 5
"""
numbers = [(10, -2, 3, 4), (-13, 56), (1, 9, 2), (-1, -9, -45, 32), (-1, 5, 1), (17, 0, 1), (0, 1), (3,), (39, 12), (11, -23), (10, -100, 21, 32), (3, -8), (1, 1)]

sorted_numbers = sorted(numbers, key=lambda x: sum(x)/len(x), reverse=True)

print(sorted_numbers)
"""
# 10
"""
def comparator(s):
    s = s.upper()
    result = sum([(ord(x)-ord('A')) for x in s])
    return result

res = sorted([input() for _ in range(int(input()))])
res = sorted(res, key=comparator)
print(*res, sep='\n')
"""
# 11
"""
def predicator(s):
    s = s.split('.')
    return int(s[0])*(256**3) + int(s[1])*(256**2) + int(s[2])*(256**1) + int(s[3])*(256**0)


ip_addresses = [input() for _ in range(int(input()))]
ip_addresses = sorted(ip_addresses, key=predicator)
print(*ip_addresses, sep='\n')
"""
# Модуль 17.3
# 9
"""
with open('lines.txt', encoding='utf-8') as file:
    res = file.readlines()
    [print(s.rstrip()) if len(s)==len(max(res, key=lambda x: len(x))) else print(end='') for s in res]
"""
# 10
"""
with open('numbers.txt') as file:
    [print(sum(map(int, line.split()))) for line in file]

"""
# 11
"""
with open('nums.txt', encoding='utf-8') as file:
    resS = ''
    for S in file:
        for i in range(len(S)):
            if S[i].isdigit():
                resS += (S[i])
            else:
                resS += ' '
    print(sum([int(x) for x in resS.split()]))
"""
# 12
"""
with open("file.txt") as file:
    letters, words, lines = 0, 0, 0

    for stroka in file:
        letters += sum([1 for s in stroka if s.isalpha()]) 
        words += stroka[:-1].count(' ') + 1
        lines += 1
        
    print(f'Input file contains:\n{letters} letters\n{words} words\n{lines} lines')
"""
# 13
"""
from random import sample

with open('first_names.txt') as file1, open('last_names.txt') as file2:
    first_name = sample([s.strip() for s in file1.readlines()], 3)
    last_name = sample([s.strip() for s in file2.readlines()], 3)
    
    for i in range(3):
        print(f'{first_name[i]} {last_name[i]}')
"""
# 14
"""
with open('population.txt') as file:
    for s in file.readlines():
        s = s.split()
        if s[0][0] == 'G' and int(s[-1]) > 500000:
            print(s[0])
"""
# 15
'''
def file_csv():
    with open("data.csv") as file:
        mas = []
        keys_dict = []
        
        for s in file.readline().rstrip().split(","):
            keys_dict.append(s)

        for line in file.readlines():
            my_dict = {}
            line = line.rstrip().split(',')
            for i in range(len(line)):
                my_dict[keys_dict[i]] = line[i]
            mas.append(my_dict)
        
        print(*mas, sep = '\n')

file_csv()
'''
# Модуль 17.3
# 10
'''
with open('input.txt','r') as file1, open('output.txt','w') as file2:
    for i,v in enumerate([s.rstrip() for s in file1.readlines()], start=1):
        file2.write(f'{i}) {v}\n')
'''
# 11
'''
with open('class_scores.txt','r') as file1, open('new_scores.txt','w') as file2:
    for s in [s.rstrip() for s in file1.readlines()]:
        s = s.split()
        print(f'{s[0]} {(int(s[1])+5 if int(s[1])<=95 else 100)}', file=file2)
'''
# 12
'''
with open('goats.txt','r') as file1, open('answer.txt','w') as file2:
    file1.readline()
    colors_goat = {}
    k = 0

    s = file1.readline().rstrip()
    while s != 'GOATS':
        colors_goat[s] = 0
        s = file1.readline().rstrip()
    
    for line in [s.rstrip() for s in file1.readlines()]:
        colors_goat[line] += 1
        k += 1

    for key,value in sorted(colors_goat.items()):
        if value/k > 0.07:
            print(f'{key}', file=file2)
'''
# 13
'''
with open('output.txt','w') as file_output:
    for _ in range(int(input())):
        with open(input()) as file:
            file_output.write(file.read())
'''
# 14
'''
with open('logfile.txt','r', encoding='utf-8') as file1, open('output.txt','w', encoding='utf-8') as file2:
    for s in [s.rstrip().split(', ',) for s in file1.readlines()]:
        time1, time2 = s[1].split(':'), s[2].split(':')
        if ( int(time2[0])*60 + int(time2[1]) ) - ( int(time1[0])*60 + int(time1[1]) ) >= 60:
            print(s[0] , file=file2)
'''
# Модуль 18.1
# 1
'''
with open(input(), 'r') as file:
    print(len(file.readlines()))
'''
# 2
'''
with open('ledger.txt', 'r') as file:
    print(f'${sum([int(x.rstrip()[1:]) for x in file.readlines()])}')
    '''
# 3
'''
with open('grades.txt','r') as file:
    k = 0
    for s in file.readlines():
        s = s.rstrip().split()
        if int(s[1]) >= 65 and int(s[2]) >= 65 and int(s[3]) >= 65:
            k+=1
    print(k)
'''
# 4
'''
with open('words.txt','r',encoding='utf-8') as file:
    words = file.read().split()
    [print(s) for s in words if len(s) == len(max(words, key=lambda x: len(x)))]
'''
# 5
'''
# не оптимизированное
with open(input(),'r') as file:
    lines = [s.rstrip() for s in file.readlines()]
    print(*lines[-10:], sep='\n')
'''
# 6
'''
with open('forbidden_words.txt','r',encoding='utf-8') as fucks, open(input(),'r',encoding='utf-8') as file:
    all_words = file.read()
    all_words_lower = all_words.lower()

    for fuck in fucks.read().split(' '):
        all_words_lower = all_words_lower.replace(fuck,'*'*len(fuck))
    
    for i in range(len(all_words)):
        if all_words_lower[i] == '*' and all_words_lower[i] != all_words[i]:
            all_words = all_words[:i]+'*'+all_words[i+1:]
    
    print(all_words)

'''
# 7
'''
with open('cyrillic.txt','r',encoding='utf-8') as text, open('transliteration.txt','w',encoding='utf-8') as new_file:
    d = {
    'а': 'a', 'к': 'k', 'х': 'h', 'б': 'b', 'л': 'l', 'ц': 'c', 'в': 'v', 'м': 'm', 'ч': 'ch',
    'г': 'g', 'н': 'n', 'ш': 'sh', 'д': 'd', 'о': 'o', 'щ': 'shh', 'е': 'e', 'п': 'p', 'ъ': '*',
    'ё': 'jo', 'р': 'r', 'ы': 'y', 'ж': 'zh', 'с': 's', 'ь': "'", 'з': 'z', 'т': 't', 'э': 'je',
    'и': 'i', 'у': 'u', 'ю': 'ju', 'й': 'j', 'ф': 'f', 'я': 'ya'
    }

    for symbol in text.read():
        if symbol.lower() in d:
            if symbol.islower():
                new_file.write(d[symbol])
            elif symbol.isupper():
                new_file.write(d[symbol.lower()].capitalize())
        else:
            new_file.write(symbol)
'''
# 8
'''
with open(input(),'r') as cod:
    mas = ['.',cod.readline()]
    flag = True
    while mas[0] != '' or mas[1] != '':
        if mas[0][0] != '#' and mas[1][:4] == 'def ':
            print(mas[1].split()[1].split('(')[0])
            flag = False
        del mas[0]
        mas.append(cod.readline())
    if flag:
        print('Best Programming Team')
'''

















































































































