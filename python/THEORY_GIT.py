# Git / Терминал: базовые команды для работы с директориями



# ===== `dir` =====  
'''
# Выводит список файлов и папок в текущей директории.  
# Используется в командной строке Windows.
# 'dir'    - Windows
# 'ls'     - Linux / macOS
'''


# ===== `cd <путь>` =====
''' 
#  Команда смены каталога (папки).  
#  Пример:  
# - Переходит в папку `code` из текущей директории.  
# - Можно использовать относительный путь (`..` — переход на уровень выше).  
# - Полезно для навигации по файловой системе перед выполнением git-команд.
'''


# ===== Инициализация репозитория =====
'''
# 'git init'
# Создаёт новый пустой git-репозиторий в текущей папке.
# Создаётся скрытая папка .git с настройками и историей.
#
# Пример использования:
# cd путь/к/проекту
# git init
'''


# ===== Загрузка кода на Git =====
'''
# 'git add <файл/папка>'
# Добавляет изменения в индекс (стейджинг) для следующего коммита.
# Пример: git add .  — добавить все изменения
#
# 'git commit -m "Сообщение" '
# Создаёт коммит с описанием изменений.
#
# 'git branch -M main'
# Переименовывает текущую ветку в main (стандарт для новых репозиториев).
# Нужно делать, если ветка называется по-другому.
# 
# 'git remote add origin <URL>'
# Добавляет удалённый репозиторий с именем origin.
# URL — адрес репозитория на GitHub/GitLab/другом сервисе.
# Эта команда один раз связывает локальный репозиторий с удалённым.
#
# 'git push -u origin main'
# - Используется при первой отправке локальной ветки на удалённый репозиторий.
# - Флаг `-u` (или `--set-upstream`) устанавливает связь (upstream) между локальной веткой "main" и удалённой "origin/main".
# - После этого git запоминает, куда и с какой веткой синхронизироваться.
# 'git push'
# - Используется для отправки изменений в уже связанную с upstream ветку.
# - Без параметров git знает, куда пушить (если upstream настроен).
#
#
#
# Пример последовательности, когда уже всё настроено:
# git add .
# git commit -m "new commit"
# git push
'''


# ===== 'git clone' =====
'''
# git clone <URL>
# Копирует (клонирует) удалённый репозиторий с указанного URL на ваш компьютер.
# Создаёт новую папку с именем репозитория и загружает все файлы и историю.
#
# Пример:
# git clone https://github.com/user/repo.git
'''


# ===== 'git status' =====
'''
# git status
# Показывает текущее состояние рабочего каталога и индекса.
# Выводит информацию:
# - Какие файлы изменены, но не добавлены (unstaged changes)
# - Какие файлы готовы к коммиту (staged changes)
# - Какие файлы не отслеживаются Git
# - Текущая ветка и статус слияния (merge)
#
# Используется для контроля перед коммитом, чтобы увидеть, что изменилось.
#
# 'git status --short'
# Выводит состояние репозитория в компактном виде.
# Каждая изменённая или новая строка занимает одну короткую строку.
# Позволяет быстро увидеть изменения без большого описания.
'''


# ===== Настройка алиасов для удобства =====
'''
# Алиасы — это сокращённые названия команд git, которые вы задаёте в конфигурации.
# Позволяют быстро выполнять длинные или часто используемые команды.

# Пример настройки алиасов в файле .gitconfig (обычно в домашней папке):

# [alias]
#   s = status --short
#   l = log --oneline --graph --decorate --all
#   g = log --graph --abbrev-commit --decorate --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)'

# Значение:
# - git s          → вызывает 'git status --short'
# - git l          → компактный граф коммитов с дополнениями
# - git g          → расширенный цветной лог с форматированным выводом

# Чтобы задать эти алиасы, выполните:
# git config --global alias.s "status --short"
# git config --global alias.l "log --oneline --graph --decorate --all"
# git config --global alias.g "log --graph --abbrev-commit --decorate --all --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(dim white) - %an%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n %C(white)%s%C(reset)'"

# После этого используйте просто:
# git s
# git l
# git g

# Это экономит время, улучшает читаемость и ускоряет работу с git.
'''


# ===== Команда git reset =====
'''
# git reset
# Отменяет добавление файлов в индекс (staging area), возвращая их в состояние "неизменённых для коммита".
# Используется для "снятия" изменений из индекса перед коммитом.

# Пример:
# git reset <файл>   # удаляет конкретный файл из индекса, оставляя изменения в рабочем каталоге
# git reset          # сбрасывает индекс целиком, все файлы становятся unstaged

# Важно:
# - git reset не удаляет изменения из файлов, только убирает их из индекса.
# - Для отмены самих изменений нужен `git checkout` или `git restore`.
'''


# ===== Отмена изменений в файлах: git checkout =====
'''
# git checkout -- <файл>
# Отменяет все несохранённые (непроиндексированные) изменения в указанном файле.
# Восстанавливает файл из последнего коммита (HEAD).
#
# Пример:
# git checkout -- README.md
#
# git checkout -- .
# Отменяет все несохранённые изменения во всех файлах в текущей директории и её поддиректориях.
#
# Важно:
# - Используйте с осторожностью, т.к. изменения будут потеряны!
# - Только работает с изменениями, которые не были добавлены в индекс (staged).
'''


# ===== Отмена коммитов: git reset с флагами =====
'''
# git reset --soft HEAD^1
# Отменяет последний коммит, сохраняя все изменения в индексе (staging area).
# HEAD^1 — ссылка на предыдущий коммит (на один назад от текущего).
# Используется, когда нужно изменить последний коммит, но оставить изменения подготовленными к новому коммиту.

# git reset --hard HEAD^1
# Полностью отменяет последний коммит и все изменения в файлах рабочего каталога и индексе.
# Восстанавливает состояние репозитория к предыдущему коммиту без сохранения изменений.
# Используйте осторожно, т.к. изменения потеряются безвозвратно!

# Пример использования:
# git reset --soft HEAD^1   # откатить последний коммит, изменения готовы к повторному коммиту
# git reset --hard HEAD^1   # полностью откатить последний коммит и изменения к нему

# Обозначения:
# HEAD — текущий коммит
# HEAD^1 или HEAD~1 — родитель текущего коммита (на 1 назад)
'''


# ===== Работа с ветками в Git =====
'''
# Создание новой ветки:
# git branch <имя_ветки>

# Переключение на ветку:
# git checkout <имя_ветки>

# Одновременное создание и переключение:
# git checkout -b <имя_ветки>

# Просмотр списка веток:
# git branch
#
# Дополнительно с подробностями:
# git branch -v
# Отображает ветки с последним коммитом и его сообщением.

# Удаление ветки:
# git branch -d <имя_ветки>
# (если ветка не слита — git branch -D <имя_ветки>)

# Отправка ветки на удалённый репозиторий:
# git push -u origin <имя_ветки>

# Установка или изменение имени ветки по умолчанию:
# git branch -M main  # переименовать текущую ветку в main

# Пример последовательности:
# git branch feature     # создать ветку feature
# git checkout feature   # перейти в неё
# git push -u origin feature  # отправить на удалённый репозиторий и установить upstream
'''


# ===== Принудительный пуш: git push --force =====
'''
# git push --force
# Перезаписывает удалённую ветку содержимым локальной ветки,
# даже если их история расходится.
# Используется для переписывания истории или отката ветки на сервере.
# Будьте осторожны – возможна потеря коммитов, уникальных для удалённого репозитория.

# git push --force-with-lease
# Более безопасный альтернативный вариант принудительного пуша.
# Проверяет, что удалённая ветка не была изменена другими с момента последнего fetch.
# Если были изменения - пуш прервётся, что предотвращает непреднамеренную потерю данных.

# Пример использования:
# git push origin main --force
# Перезапишет ветку main в удалённом репозитории содержимым локальной ветки main.

# git push origin main --force-with-lease
# Безопасно перезапишет ветку main, если удалённая ветка не изменялась.

# Важно:
# Используйте с осторожностью и только когда уверены, что перезапись не повредит работе других участников проекта.
'''

































































